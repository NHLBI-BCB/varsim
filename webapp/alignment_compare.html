<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="VarSim &#8212; Alignment Compare">
    <meta name="author" content="John C. Mu">

    <title>VarSim &#8212; Alignment Compare</title>

    <script>
    <!--varsim_data-->

    </script>

    <!-- Bootstrap core CSS -->
    <link href="http://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css" rel="stylesheet">

</head>

<style>
    body {
    padding-top: 70px;
    }
    .btn-file {
    position: relative;
    overflow: hidden;
    }
    .btn-file input[type=file] {
    position: absolute;
    top: 0;
    right: 0;
    min-width: 100%;
    min-height: 100%;
    font-size: 999px;
    text-align: right;
    filter: alpha(opacity=0);
    opacity: 0;
    outline: none;
    background: white;
    cursor: inherit;
    display: block;
    }
    .axis {
    font: 10px sans-serif;
    }
    .axis path,
    .axis line {
    fill: none;
    stroke: #000;
    shape-rendering: crispEdges;
    }
    a.anchor {
    display: block;
    position: relative;
    top: -70px;
    visibility: hidden;
    }
</style>

<body>

<!-- Fixed navbar -->
<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <a class="navbar-brand" href="#">VarSim &#8212; Alignment Compare</a>
        </div>
        <div class="navbar-collapse collapse">
            <ul class="nav navbar-nav">
                <li>
                    <a href="#parameters">Parameters</a>
                </li>

                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Variant Types <span class="caret"></span></a>
                    <ul class="dropdown-menu" role="menu" id="stats_menu">

                    </ul>
                </li>

            </ul>

            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="javascript:hide_all();show_id('about');scroll_to('a_about');">About</a>
                </li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="javascript:hide_all();show_id('help');scroll_to('a_help');">Help</a>
                </li>
            </ul>
        </div>
        <!--/.nav-collapse -->
    </div>
</div>

<div class="container">
    <a id="parameters" class="anchor"></a>

    <div class="panel panel-default">
        <div class="panel-body">
            <button type="button" id="reset_button" class="btn btn-default">
                Clear plots
            </button>
                <span class="btn btn-default btn-file"> Add data sets (.json)
						<input type="file" id="files" name="files[]" multiple/>
					</span>

            <span> &nbsp; Add data set to see results or <a href="javascript:load_demo()">load some demo data</a> </span>

            <p>

            <div id="file_name_list"></div>
            </p>
        </div>
    </div>

    <div id="stats_plot">

    </div>

    <a id="a_help" class="anchor"></a>

    <div id="help" style="padding-bottom: 400px;">
        <div class="panel">
            <h2>Quick Start</h2>

            <p>
                This web application takes the results from VarSim SAMcompare and displays them in an interactive plot.
                For instructions on how to run SAMcompare, please see [link].
            </p>

            <p>
                Steps for basic usage:
            <ol>
                <li>Run SAMcompare to generate one or more .json files that contains the accuracy results.</li>
                <li>Click "Add data sets" (above) and select the .json files you would like to compare.</li>
                <li>The resulting plots generated are grouped by the type of variation each read overlaps in the truth
                    set.
                </li>
                <li>You can click on the plots to change the selection mode.</li>
            </ol>
            </p>
            <h2>Introduction</h2>

            <p>
                VarSim provides an easy and flexible way to compare secondary analysis workflows. Alignment Compare is
                for displaying the accuracy results for alignment tools based on the truth set generated by VarSim. It
                is able to break down the comparison into different regions of the genome based on the type of variant
                each read overlaps. The curves are generated by varying the MAPQ cut-off.
            </p>

            <h2>Details</h2>

            <h3>Plot generation</h3>

            <p>
                The plots are generated by varying the MAPQ cut-off. That is for each point alignments are filtered as
                greater or equal to the MAPQ value.
            </p>

            <h3>Axes</h3>

            <p>
                VarSim plots Sensitivity (TPR) versus FDR. TPR is defined as TP/(TP+FN) and FDR is defined as
                FP/(FP+TP).
            </p>

            <h3>Selection modes</h3>

            <p>
            <ul>
                <li><b>Closest point:</b> The closest (euclidian) point to the cursor for each series will be selected.
                </li>
                <li><b>X lock:</b> The closest (euclidian) point to the cursor on the X-axis for each series will be
                    selected.
                </li>
                <li><b>Y lock:</b> The closest (euclidian) point to the cursor on the Y-axis for each series will be
                    selected.
                </li>
                <li><b>Closest MAPQ:</b> The MAPQ of the closest (euclidian) point to the cursor is recorded. For each
                    series, the point with the closest MAPQ to this value is selected.
                </li>
            </ul>
            </p>

            <h2>Limitations</h2>

            <p>
                Points with less than 30% of the reads aligned are not plotted since those are potentially noisy and not
                so useful.
            </p>

        </div>
    </div>

    <a id="a_about" class="anchor"></a>

    <div id="about" style="padding-bottom: 400px;">
        <div class="jumbotron">
            <h1>VarSim &#8212; Alignment Compare</h1>

            <p>
                Display detailed results for alignment comparison.
            </p>

            <p>
                Please read the <a href="javascript:hide_all();show_id('help');scroll_to('a_help');">help</a> before
                use.
            </p>

            <p>
                Contact us at <a href="mailto:rd@bina.com">rd@bina.com</a>
            </p>
        </div>
    </div>

    <!-- /container -->
</div>

<!-- Bootstrap core JavaScript
    ================================================== -->
<!-- Placed at the end of the document so the pages load faster -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
<script src="http://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js"></script>
<script src="http://cdnjs.cloudflare.com/ajax/libs/d3/3.4.11/d3.min.js"></script>

<script>
        // constants
        var all_height = 680;
        var all_width = 700;
        var chart_width = 500;
        var chart_height = 350;
        var tool_tip_height = 240;
        var left_margin = 60;

        var legend_x = 10;
        var legend_y = 50;
        var legend_height = 190;
        var legend_x_margin = 20;
        var legend_y_margin = 20;

         // style constants
        var front_style = "fill: rgba(0, 0, 0, 0);";
        var color_arr = ["#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd","#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf"]

        var stats_data = {};

        function scroll_to(id) {
            $("#" + id)[0].scrollIntoView();
        }

        function show_id(id) {
            $('#' + id).show();
        }

        function hide_id(id) {
            $('#' + id).hide();
        }

        function clear_plots_id(id) {
            // clear the plots for the variants
            $("#" + id + "_plot").empty();
            $("#" + id + "_menu").empty();
        }

        function hide_all() {
            hide_id('about');
            hide_id('help');
            hide_id('stats_plot');
        }

         // processing functions
        function compute_tpr(obj) {
            if (obj == null) {
                return [NaN, 0];
            }

            if (obj._T == 0 || obj._TP == 0) {
                return [NaN, obj._TP];
            }
            return [obj._TP / obj._T, obj._TP];
        }

        function compute_tnr(obj) {
            if (obj == null) {
                return [NaN, 0];
            }

            if (obj._FP + obj._TN == 0 || obj._TN == 0) {
                return [NaN, obj._TN];
            }
            return [obj._TN / (obj._FP + obj._TN), obj._TN];
        }


        function compute_fdr(obj) {
            if (obj == null) {
                return [NaN, 0];
            }

            if ((obj._TP + obj._FP) == 0) {
                return [NaN, obj._FP];
            }
            return [obj._FP / (obj._TP + obj._FP), obj._FP];
        }

        function compute_fpr(obj) {
            if (obj == null) {
                return [NaN, 0];
            }

            if ((obj._TN + obj._FP) == 0) {
                return [NaN, obj._FP];
            }
            return [obj._FP / (obj._TN + obj._FP), obj._FP];
        }

        function compute_ppv(obj) {
            if (obj == null) {
                return [NaN, 0];
            }

            if ((obj._TP + obj._FP) == 0) {
                return [NaN, obj._FP];
            }
            return [obj._TP / (obj._TP + obj._FP), obj._FP];
        }

        function compute_log_true(obj) {
            if (obj == null) {
                return [NaN, 0];
            }

            if (obj._T == 0) {
                return [NaN, obj._T];
            }
            return [Math.log(obj._T) / Math.log(10), obj._T];
        }

        function compute_true(obj) {
            if (obj == null) {
                return [NaN, 0];
            }

            if (obj._T == 0) {
                return [NaN, obj._T];
            }
            return [obj._T, obj._T];
        }

        function compute_true_negative(obj) {
            if (obj == null) {
                return [NaN, 0];
            }

            return [obj._TN, obj._TN];
        }


         ///////  end processing funtions



        /**
         *    returns the range of the data, sets to NaN useless values
         *
         *    @param {data} the data object loaded from JSON
         *    @param {type} string for the variant type
         *    @param {func} processing function, eg. compute_tpr, this function returns an array with 2 elements
         *    @param {log_scale} boolean, whether the range is in log scale
         *    limit_range -- limit to 1
         *    @return {range} array of size 2, [lower, upper], optionally log scale
         */
        function compute_range(data, type, func, log_range, limit_range) {
            var range = [Infinity, -Infinity];

            for (var filename in data) {

                if (!data[filename].hasOwnProperty(type)) {
                    continue;
                }

                var contents = data[filename][type];

                for (var idx in contents) {
                    var obj = contents[idx];
                    var val = func(obj)[0];

                    if (isNaN(val)) {
                        continue;
                    }

                    if (log_range && val == 0) {
                        continue;
                    }

                    if (val < range[0]) {
                        range[0] = val;
                    }
                    if (val > range[1]) {
                        range[1] = val;
                    }
                }
            }

            if (!isFinite(range[0]) || !isFinite(range[1])) {
                return [0, 1];
            }

            if (!log_range) {
                var diff = (range[1] - range[0]);
                range[0] = Math.max(0, range[0] - (0.01 * diff) - 0.001);
                if (limit_range) {
                    range[1] = Math.min(1, range[1] + (0.01 * diff) + 0.001);
                } else {
                    range[1] = range[1] + (0.01 * diff) + 0.001;
                }
            } else {
                range[0] *= 0.5;
                if (limit_range) {
                    range[1] = Math.min(1, range[1] * 2);
                } else {
                    range[1] = range[1] * 2;
                }
            }

            return range;
        }


        function draw_y_axis(parent, x_pos, y_pos, height, domain, label) {
            var y = null;
            var yAxis = null;
            y = d3.scale.linear().range([height, 0]);
            yAxis = d3.svg.axis().scale(y).orient("left").ticks(10, "%");
            y.domain(domain);


            parent.append("g")
                .attr("class", "y axis")
                .attr("transform", "translate(" + x_pos + "," + y_pos + ")")
                .call(yAxis)
                .append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", -55)
                .attr("x", -210)
                .attr("dy", ".71em")
                .style("font-size", 14)
                .text(label);
            return y;
        }

        function draw_x_axis(parent, x_pos, y_pos, width, domain, label) {

            var x = d3.scale.log().range([0, width]);
            var xAxis = d3.svg.axis().scale(x).orient("bottom").ticks(15);

            x.domain(domain);

            var axis = parent.append("g")
                .attr("class", "x axis")
                .attr("transform", "translate(" + x_pos + "," + y_pos + ")")
                .call(xAxis);

            axis.selectAll("text")
                .style("text-anchor", "end")
                .attr("dx", "-.8em")
                .attr("dy", ".15em")
                .attr("transform", function (d) {
                    return "rotate(-30)"
                });

            axis.append("text")
                .attr("y", 40)
                .attr("x", 220)
                .attr("dy", ".71em")
                .style("font-size", 14)
                .text(label);

            return x;
        }

        /**
         * We want to reject data points with less than 1/3 aligned, those are pretty noisy
         */
        function get_valid_data(big_data) {
            var REJECT_RATIO = 0.3333;

            var valid_data = {};
            for (var filename in big_data) {
                var type_data = big_data[filename];
                valid_data[filename] = {};

                for (var type in type_data) {
                    var data_arr = type_data[type].data;
                    var max_P = 0; // maximum number of alignments
                    var out_arr = [];

                    for (var idx in data_arr) {
                        var contents = data_arr[idx];
                        var P_val = contents._TP + contents._FP;
                        if (max_P < P_val) {
                            max_P = P_val;
                        }
                    }

                    var P_limit = max_P * REJECT_RATIO;

                    for (var idx in data_arr) {
                        var contents = data_arr[idx];
                        var P_val = contents._TP + contents._FP;

                        var prev_val = out_arr[out_arr.length - 1];
                        if (out_arr.length > 0 && contents._FP == prev_val._FP && contents._TP == prev_val._TP && contents._T == prev_val._T) {
                            continue;
                        }

                        if (P_val >= P_limit) {
                            // keep this one
                            out_arr.push(contents);
                        }
                    }

                    valid_data[filename][type] = out_arr;
                }
            }

            return valid_data;
        }

        function get_x_val(val, x_scale) {
            if (val <= 0) {
                return 0
            } else {
                return x_scale(val);
            }
        }

        /**
         * Draws one chart
         * Returns an array of coordinates used for interactivity
         */
        function draw_chart(parent, id, big_data, type, color_arr) {

            var chart_area_x = left_margin;
            var chart_area_y = tool_tip_height + chart_height;

            // compute the valid datapoints
            var valid_data = get_valid_data(big_data);

            if (type == 'True_Unmapped') {
                var y_compute = compute_tnr;
                var x_compute = compute_true_negative;
            } else {
                var y_compute = compute_tpr;
                var x_compute = compute_fdr;
            }

            // define the x_axis and y_axis range
            if (type == 'True_Unmapped') {
                var x_range = compute_range(valid_data, type, x_compute, true, false); // FDR
            } else {
                var x_range = compute_range(valid_data, type, x_compute, true, true); // FDR
            }
            var y_range = compute_range(valid_data, type, y_compute, false, true); // sensitivity (recall)

            // draw the y axis
            if (type == 'True_Unmapped') {
                var y_scale = draw_y_axis(parent, left_margin, tool_tip_height, chart_height, y_range, "Specificity (SPC)");
            } else {
                var y_scale = draw_y_axis(parent, left_margin, tool_tip_height, chart_height, y_range, "Sensitivity (TPR)");
            }
            // draw the x axis
            if (type == 'True_Unmapped') {
                var x_scale = draw_x_axis(parent, left_margin, chart_area_y, chart_width, x_range, "Number Correctly Unmapped")
            } else {
                var x_scale = draw_x_axis(parent, left_margin, chart_area_y, chart_width, x_range, "False Discovery Rate (FDR)")
            }

            var file_array = {};

            // draw the line plot
            var file_idx = 0;
            for (filename in valid_data) {
                // stores an array of objects with coordinates and corresponding values
                var coord_array = [];

                var data_arr = valid_data[filename];
                if (data_arr.hasOwnProperty(type)) {
                    data_arr = data_arr[type];

                    var idx = 0;

                    // plot first data point
                    var x_val = x_compute(data_arr[idx]);
                    var x1 = chart_area_x + get_x_val(x_val[0], x_scale);
                    var y_val = y_compute(data_arr[idx]);
                    var y1 = chart_area_y - chart_height + y_scale(y_val[0]);

                    coord_array.push({
                        'x': x1,
                        'y': y1,
                        'x_val': x_val,
                        'y_val': y_val,
                        'T': data_arr[idx]._T,
                        'P': data_arr[idx]._TP + data_arr[idx]._FN,
                        'N': data_arr[idx]._TN + data_arr[idx]._FP,
                        'mapq': data_arr[idx].upper
                    });

                    if (x_val[0] > 0) {
                        parent.append("path")
                            .attr("transform", function (d) {
                                return "translate(" + x1 + "," + y1 + ")";
                            })
                        //.attr("d", d3.svg.symbol().type('cross').size(32))
                        .attr("d", "M0,0 L2,2 M0,0 L2,-2 M0,0 L-2,2 M0,0 L-2,-2")
                            .attr("style", "stroke-width:1;stroke:" + color_arr[file_idx] + ";");
                    } else {
                        parent.append("path")
                            .attr("transform", function (d) {
                                return "translate(" + x1 + "," + y1 + ")";
                            })
                            .attr("d", d3.svg.symbol().type('circle').size(24))
                            .attr("style", "stroke:" + color_arr[file_idx] + ";fill:none");
                    }
                    idx++;

                    // plot rest of the data points
                    for (; idx < data_arr.length; idx++) {
                        var prev_contents = data_arr[idx - 1];
                        var contents = data_arr[idx];

                        var x1_val = x_compute(prev_contents);
                        var x1 = chart_area_x + get_x_val(x1_val[0], x_scale);
                        var y1_val = y_compute(prev_contents);
                        var y1 = chart_area_y - chart_height + y_scale(y1_val[0]);
                        var x2_val = x_compute(contents);
                        var x2 = chart_area_x + get_x_val(x2_val[0], x_scale);
                        var y2_val = y_compute(contents);
                        var y2 = chart_area_y - chart_height + y_scale(y2_val[0]);

                        parent.append("line")
                            .attr("x1", x1)
                            .attr("x2", x2)
                            .attr("y1", y1)
                            .attr("y2", y2)
                            .attr("style", "stroke-opacity: 0.8; stroke: " + color_arr[file_idx] + "; stroke-width: 1.5;");

                        coord_array.push({
                            'x': x2,
                            'y': y2,
                            'x_val': x2_val,
                            'y_val': y2_val,
                            'T': contents._T,
                            'P': contents._TP + contents._FN,
                            'N': contents._TN + contents._FP,
                            'mapq': contents.upper
                        });

                        if (x2_val[0] > 0) {
                            parent.append("path")
                                .attr("transform", function (d) {
                                    return "translate(" + x2 + "," + y2 + ")";
                                })
                            //.attr("d", d3.svg.symbol().type('cross').size(32))
                            .attr("d", "M0,0 L2,2 M0,0 L2,-2 M0,0 L-2,2 M0,0 L-2,-2")
                                .attr("style", "stroke-width:1;stroke: " + color_arr[file_idx] + ";");
                        } else {
                            parent.append("path")
                                .attr("transform", function (d) {
                                    return "translate(" + x2 + "," + y2 + ")";
                                })
                                .attr("d", d3.svg.symbol().type('circle').size(24))
                                .attr("style", "stroke : " + color_arr[file_idx] + ";fill:none");
                        }
                    }
                }

                file_array[filename] = coord_array;

                file_idx++;
            }

            // compute the AUC here
            var AUC_vals = {};

            for (var filename in valid_data) {
                var temp_data = valid_data[filename];

                if (!temp_data.hasOwnProperty(type)) {
                    continue;
                }

                var AUC_data = [];

                for (var idx in temp_data[type]) {
                    AUC_data.push([compute_fdr(temp_data[type][idx]), compute_tpr(temp_data[type][idx])]);
                }
                //AUC_data.sort();
                AUC_data.reverse();

                var curr_auc_val = 0;
                var i = 0;
                for (i = 0; i < AUC_data.length - 2; i++) {
                    var fdr1 = AUC_data[i][0][0];
                    var tpr1 = AUC_data[i][1][0];
                    var fdr2 = AUC_data[i + 1][0][0];
                    var tpr2 = AUC_data[i + 1][1][0];

                    var width = Math.abs(fdr2 - fdr1);
                    var height_1 = Math.abs(tpr2 - tpr1);
                    var height_2 = Math.max(tpr2, tpr1);

                    curr_auc_val += (height_2 * width) - (0.5 * width * height_1);
                }

                // add the last block in the AUC
                var fdr2 = AUC_data[AUC_data.length - 2][0][0];
                var tpr2 = AUC_data[AUC_data.length - 2][1][0];
                curr_auc_val += (1 - fdr2) * tpr2;

                AUC_vals[filename] = curr_auc_val;
            }

            if (type != 'True_Unmapped') {
                draw_auc(parent, legend_x + legend_x_margin, legend_y + legend_y_margin, AUC_vals);
            }
            //console.log(type + ":" + JSON.stringify(AUC_vals));

            var circle_arr = [];
            var legend_arr = [];

            var file_idx = 0;
            for (filename in valid_data) {
                // draw a circle to move around
                circle_arr.push(parent.append("path")
                    .attr("transform", function (d) {
                        return "translate(" + 0 + "," + 0 + ")";
                    })
                    .attr("d", d3.svg.symbol().type('circle').size(64))
                    .attr("style", "stroke-width:2.0;stroke : " + color_arr[file_idx] + ";fill:rgba(0, 0, 0, 0.36)")
                    .style("visibility", "hidden"));

                // draw the legend text
                legend_arr.push([parent.append("text")
                    .attr("x", legend_x + legend_x_margin + 150)
                    .attr("y", (legend_y + legend_y_margin + (file_idx * 15) + 5))
                    .attr("font-family", "sans-serif")
                    .attr("font-size", "12px")
                    .attr("fill", "black")
                    .style("visibility", "hidden"),
                                 parent.append("text")
                    .attr("x", legend_x + legend_x_margin + 230)
                    .attr("y", (legend_y + legend_y_margin + (file_idx * 15) + 5))
                    .attr("font-family", "sans-serif")
                    .attr("font-size", "12px")
                    .attr("fill", "black")
                    .style("visibility", "hidden"),
                                 parent.append("text")
                    .attr("x", legend_x + legend_x_margin + 470)
                    .attr("y", (legend_y + legend_y_margin + (file_idx * 15) + 5))
                    .attr("font-family", "sans-serif")
                    .attr("font-size", "12px")
                    .attr("fill", "black")
                    .style("visibility", "hidden")]);
                file_idx++;
            }

            // draw two lines to move around the area
            var x_line = parent.append("line")
                .attr("x1", chart_area_x)
                .attr("x2", chart_area_x + chart_width)
                .attr("y1", chart_area_y)
                .attr("y2", chart_area_y)
                .style("stroke-dasharray", ("3, 6"))
                .style("stroke", "rgba(0, 0, 0, 0.25)")
                .style("stroke-width", "1.0")
                .style("visibility", "hidden");
            var y_line = parent.append("line")
                .attr("x1", chart_area_x)
                .attr("x2", chart_area_x)
                .attr("y1", tool_tip_height)
                .attr("y2", chart_area_y)
                .style("stroke-dasharray", ("3, 6"))
                .style("stroke", "rgba(0, 0, 0, 0.25)")
                .style("stroke-width", "1.0")
                .style("visibility", "hidden");

            // the mode text
            var mode = 0;

            function get_mode_text(val) {
                switch (val) {
                case 0:
                    return 'Closest point';
                case 1:
                    return 'X Lock';
                case 2:
                    return 'Y Lock';
                case 3:
                    return 'Closest MAPQ';
                }
            }

            var mode_text = parent.append("text")
                .attr("x", 430)
                .attr("y", 500)
                .attr("font-family", "sans-serif")
                .attr("font-size", "14px")
                .attr("fill", "rgba(0, 0, 0, 0.60)")
                .text(get_mode_text(mode))
                .style("visibility", "hidden");

            var mode_help_text = parent.append("text")
                .attr("x", 430)
                .attr("y", 510)
                .attr("font-family", "sans-serif")
                .attr("font-size", "10px")
                .attr("fill", "rgba(0, 0, 0, 0.60)")
                .text('Click plot to change mode')
                .style("visibility", "hidden");

            // draw the mousemove area
            var mouse_rect = parent.append("rect")
                .attr("style", front_style)
                .attr("x", chart_area_x)
                .attr("width", chart_width)
                .attr("y", tool_tip_height)
                .attr("height", chart_height);


            // do this delay thing for better performance and less lag
            var last_time;

            function move_script() {
                if ((Date.now() - last_time) < 30) return;

                var locs = d3.mouse(mouse_rect.node());

                // move the guidelines around
                x_line.attr("y1", locs[1])
                    .attr("y2", locs[1]);
                y_line.attr("x1", locs[0])
                    .attr("x2", locs[0]);

                // determine which points should be highlighted
                var best_points = [];
                var best_mapq = 0;

                if (mode == 3) {
                    // compute the mapq of the closest point
                    var best_dist = Infinity;
                    for (var filename in file_array) {
                        var contents = file_array[filename];
                        for (var idx in contents) {
                            var data = contents[idx];
                            var dist = 0;
                            dist = Math.pow(locs[0] - data.x, 2) + Math.pow(locs[1] - data.y, 2);

                            if (dist < best_dist) {
                                best_mapq = data.mapq;
                                best_dist = dist;
                            }
                        }

                    }
                }

                for (var filename in file_array) {
                    var contents = file_array[filename];
                    var best_val = null;
                    var best_dist = Infinity;
                    for (var idx in contents) {
                        var data = contents[idx];
                        var dist = 0;
                        if (mode == 0) {
                            dist = Math.pow(locs[0] - data.x, 2) + Math.pow(locs[1] - data.y, 2);
                        } else if (mode == 1) {
                            dist = Math.pow(locs[0] - data.x, 2);
                        } else if (mode == 2) {
                            dist = Math.pow(locs[1] - data.y, 2);
                        } else {
                            // mapq lock
                            dist = Math.abs(data.mapq - best_mapq);
                        }
                        if (dist < best_dist) {
                            best_val = data;
                            best_dist = dist;
                        }
                    }

                    if (best_val == null) {
                        debugger;
                    }

                    best_points.push(best_val);
                }

                // move circle to new highlighted point
                for (idx in best_points) {
                    circle_arr[idx].attr("transform", function (d) {
                        return "translate(" + best_points[idx].x + "," + best_points[idx].y + ")";
                    }).style("visibility", "visible");

                    // write the corresponding legend text
                    legend_arr[idx][0]
                        .text('MAPQ: ' + best_points[idx].mapq)
                        .style("visibility", "visible");

                    if (type == 'True_Unmapped') {
                        legend_arr[idx][1]
                            .text('TN/N: ' + best_points[idx].y_val[1] + ' / ' + (best_points[idx].N) + ' (' + (best_points[idx].y_val[0] * 100).toFixed(2) + '%)')
                            .style("visibility", "visible");
                    } else {
                        legend_arr[idx][1]
                            .text('TP/P: ' + best_points[idx].y_val[1] + ' / ' + best_points[idx].P + ' (' + (best_points[idx].y_val[0] * 100).toFixed(2) + '%)')
                            .style("visibility", "visible");
                    }

                    if (type == 'True_Unmapped') {
                        legend_arr[idx][2]
                            .text('T: ' + best_points[idx].x_val[0])
                            .style("visibility", "visible");
                    } else {
                        legend_arr[idx][2]
                            .text('FP: ' + best_points[idx].x_val[1] + ' (' + best_points[idx].x_val[0].toExponential(2) + ')')
                            .style("visibility", "visible");
                    }
                }

                // draw text for highlighted point

                last_time = Date.now();
            }

            function leave_script() {
                x_line.style("visibility", "hidden");
                y_line.style("visibility", "hidden");
                mode_text.style("visibility", "hidden");
                mode_help_text.style("visibility", "hidden");
                mouse_rect.on("mousemove", null);

                for (idx in circle_arr) {
                    circle_arr[idx].style("visibility", "hidden");
                    legend_arr[idx][0].style("visibility", "hidden");
                    legend_arr[idx][1].style("visibility", "hidden");
                    legend_arr[idx][2].style("visibility", "hidden");
                }
            }

            function enter_script() {
                x_line.style("visibility", "visible");
                y_line.style("visibility", "visible");
                mode_text.style("visibility", "visible");
                mode_help_text.style("visibility", "visible");
                mouse_rect.on("mousemove", move_script);
            }

            function click_script() {
                mode = (mode + 1) % 4;
                mode_text.text(get_mode_text(mode));
                move_script();
            }

            // add the event handlers
            mouse_rect.on("mouseleave", leave_script);
            mouse_rect.on("mouseenter", enter_script);
            mouse_rect.on("click", click_script);


        }




        function draw_auc(parent, x, y, data) {
            var idx = 0;
            for (val in data) {

                if (data[val] != null) {
                    var text = data[val].toFixed(4);

                    parent.append("text")
                        .attr("x", x + 111)
                        .attr("y", (y + (idx * 15) + 5))
                        .text(text)
                        .attr("font-family", "sans-serif")
                        .attr("font-size", "12px")
                        .attr("fill", "black");
                }
                idx++;
            }
        }


        function draw_legend(parent, x, y, data, color_arr) {
            var idx = 0;
            for (filename in data) {
                var text = filename.split('.')[0];

                parent.append("path")
                    .attr("transform", function (d) {
                        return "translate(" + x + "," + (y + (idx * 15)) + ")";
                    })
                //.attr("d", d3.svg.symbol().type('cross'))
                .attr("d", "M0,0 L3,3 M0,0 L3,-3 M0,0 L-3,3 M0,0 L-3,-3")
                    .attr("style", "stroke-width:2;stroke:" + color_arr[idx] + ";");

                parent.append("text")
                    .attr("x", x + 11)
                    .attr("y", (y + (idx * 15) + 5))
                    .text(text)
                    .attr("font-family", "sans-serif")
                    .attr("font-size", "12px")
                    .attr("fill", "black");
                idx++;
            }
        }

        /**
         *  all_data -- eg. stats_data
         *  id -- eg. stats
         */
        function redraw_plots(all_data, id) {
            clear_plots_id(id);
            var body = d3.selectAll("body");

            // get total types of variants
            var all_types = Object.create(null);
            for (var file_name in all_data) {
                for (var type in all_data[file_name]) {
                    all_types[type] = true;
                }
            }

            // for each type of variant, plot it
            for (var type in all_types) {
                var div_area = body.select("#" + id + "_plot");
                var plot_menu = body.select("#" + id + "_menu");

                // draw the anchor
                div_area.append("a").attr("id", type + "_" + id + "_menu").attr("class", "anchor");

                plot_menu.append('li').append('a').attr("href", "javascript:hide_all();show_id('" + id + "_plot');scroll_to('" + type + "_" + id + "_menu');").text(type);

                // initialise the chart
                var chart_height = all_height;

                var parent = div_area.append('svg').attr("id", type + "_" + id).attr("width", all_width).attr("height", chart_height).attr("x", 0).attr("y", 0);

                // draw the title
                parent.append('text').attr("x", 10).attr("y", 40).text(type).attr("font-family", "sans-serif").attr("font-size", "24px").attr("fill", "black");

                // draw the chart
                draw_chart(parent, id, all_data, type, color_arr);

                // draw legend/popover
                parent.append("rect")
                    .attr("style", "fill:rgba(255, 255, 255, 0);stroke:rgba(0, 0, 0, 0.09);stroke-width:1")
                    .attr("rx", 20)
                    .attr("ry", 20)
                    .attr("x", legend_x)
                    .attr("width", 650)
                    .attr("y", legend_y)
                    .attr("height", legend_height - 15);
                draw_legend(parent, legend_x + legend_x_margin, legend_y + legend_y_margin, all_data, color_arr);
            }


        }

        function store_data(varsim_obj, file_name) {
            // store the object data
            stats_data[file_name] = varsim_obj.stats.data;
        }

        function process_json(json_str, file, use_obj) {
            var pass_validation = true;
            
            if (use_obj) {
                var ll = file.name.split('/');
                file.name = ll[ll.length - 1];
            }
            
            var param_str = file.name;
            var varsim_obj = null;
            var span = document.createElement('pre');

            if (use_obj) {
                varsim_obj = json_str;
            } else {
                try {
                    varsim_obj = JSON.parse(json_str);
                } catch (err) {
                    param_str += " : [Error] Invalid JSON file.";
                    pass_validation = false;
                }
            }

            // if something is already loaded, do some consistency checks
            if (pass_validation && Object.keys(stats_data).length > 0) {
                // check consistency of the bins
                var orig_data = stats_data[Object.keys(stats_data)[0]];
                orig_data = orig_data[Object.keys(orig_data)[0]].data;

                var new_data = varsim_obj.stats.data;
                new_data = new_data[Object.keys(new_data)[0]].data;
            }

            if (pass_validation && varsim_obj != null) {
                try {
                    var params = varsim_obj.params;
                    if (params.hasOwnProperty('bam_filename')) {
                        param_str += "\n";
                        param_str += "SAM/BAM file : " + params.bam_filename + "\n";
                        param_str += "Wiggle       : " + params.wiggle + "\n";
                        param_str += "BED file     : ";
                        if (params.bed_filename.length == 0) {
                            param_str += "None";
                        } else {
                            param_str += params.bed_filename;
                        }
                    } else {
                        param_str += "[Error] Bad JSON format, are you sure this is alignment compare?.";
                    }
                } catch (err) {
                    param_str += "[Error] Error parsing JSON file.";
                    pass_validation = false;
                }
            }

            span.innerHTML = param_str;
            document.getElementById('file_name_list').insertBefore(span, null);

            if (pass_validation) {
                store_data(varsim_obj, file.name);
            }
        }

        function handleFileSelect(evt) {
            var files = evt.target.files;
            // FileList object
            var reader = new FileReader();

            function readFile(idx) {

                if (idx >= files.length) {
                    return;
                }

                var f = files[idx];
                reader.onloadend = (function (idx, file, last_one) {
                    return function (e) {
                        console.log(file);
                        if (Object.keys(stats_data).length >= color_arr.length) {
                            alert("Maximum number of files is " + color_arr.length);
                            last_one = true;
                        } else {
                            process_json(e.target.result, file, false);
                        }
                        if (last_one) {
                            // draw the plots
                            hide_all();
                            redraw_plots(stats_data, 'stats');
                            show_id('stats_plot');
                        }
                        if (!last_one) {
                            readFile(idx + 1);
                        }
                    };
                })(idx, f, (idx == files.length - 1));
                reader.readAsText(f);
            }

            readFile(0);

        }

        function load_demo() {
            reset_all_plots();

            var demo_files = ["http://bioinform.github.io/varsim/webapp/demo/bwa_aln_report.json"
                             , "http://bioinform.github.io/varsim/webapp/demo/bwa_mem_report.json"
                             , "http://bioinform.github.io/varsim/webapp/demo/novo_report.json"];

            var num_loaded = 0;
            var num_total = demo_files.length;
            for (i in demo_files) {
                console.log(demo_files[i]);
                $.getJSON(demo_files[i], (function(idx,file){
                    return function (d) {
                    var filename = {"name":file};
                    process_json(d, filename, true)
                    num_loaded++;
                    if (num_loaded == num_total) {
                        hide_all();
                        redraw_plots(stats_data, 'stats');
                        show_id('stats_plot');
                    }
                }})(i,demo_files[i]))
            }
        }

        function reset_all_plots() {
            document.getElementById('file_name_list').innerHTML = "";
            document.getElementById('stats_plot').innerHTML = "";
            resetFormElement($('#files'));
            stats_data = {};
            $("#stats_menu").empty();
        }

        function resetFormElement(e) {
            e.wrap('<form>').closest('form').get(0).reset();
            e.unwrap();
        }

         // these are run after everything is setup
         
         

        document.getElementById('files').addEventListener('change', handleFileSelect, false);
        document.getElementById('reset_button').addEventListener('click', reset_all_plots, false);

        hide_all();
        show_id('about');
        scroll_to('parameters');
        
        // check for existence of varsim_data
		if(typeof varsim_data != undefined){
			// load the data if the variable exists
			var filename = {"name": location.pathname.substring(location.pathname.lastIndexOf("/") + 1)};
            process_json(varsim_data, filename, false)
            hide_all();
            redraw_plots(stats_data, 'stats');
            show_id('stats_plot');
		}

</script>
</body>

</html>

